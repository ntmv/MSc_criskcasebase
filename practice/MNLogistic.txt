# Penalized Multinomial Logistic Regression
mtool.MNlogistic <- function(X, Y, offset, N_covariates,
                             regularization = 'l1', transpose = F,
                             lambda1, lambda2 = 0, lambda3 = 0,
                             learning_rate = 1e-4, tolerance = 1e-4,
                             niter_inner_mtplyr = 7, maxit = 100, ncores = -1,
                             group_id, group_weights,
                             groups, groups_var,
                             own_variables, N_own_variables) {
    ## Dimensions and checks
    nx <- nrow(X)

    if (!is.vector(Y)) {Y <- as.vector(Y)}
    ny <- length(Y)

    if (!is.vector(offset)) {offset <- as.vector(offset)}
    noff <- length(offset)

    if (nx == ny & nx == noff) {
        n <- nx
    } else {
        stop('X, Y and offset have different number of observations.')
    }

    p <- ncol(X)

    K <- length(unique(Y)) - 1

    ## regularization
    pen1 <- c("l0", "l1", "l2", "linf", "l2-not-squared",
              "elastic-net", "fused-lasso",
              "group-lasso-l2", "group-lasso-linf",
              "sparse-group-lasso-l2", "sparse-group-lasso-linf",
              "l1l2", "l1linf", "l1l2+l1", "l1linf+l1", "l1linf-row-column",
              "trace-norm", "trace-norm-vec", "rank", "rank-vec", "none")
    pen2 <- c("graph", "graph-ridge", "graph-l2", "multi-task-graph")
    pen3 <- c("tree-l0", "tree-l2", "tree-linf", "multi-task-tree")

    if (regularization %in% pen1) { penalty <- 1 }
    if (regularization %in% pen2) { penalty <- 2 }
    if (regularization %in% pen3) { penalty <- 3 }
    if (! regularization %in% c(pen1, pen2, pen3)) {
        stop('The provided regularization is not supported.')
    }

    ### check regularization-specific inputs
    #### penalty = 1, call proximal(Flat), requires `group_id` in integer vector
    if (penalty == 1) {
        if (missing(group_id)) { group_id <- rep(0L, p) }
        group_weights <- vector(mode = 'double')
        groups <- matrix(NA)
        groups_var <- matrix(NA)
        own_variables <- vector(mode = 'integer')
        N_own_variables <- vector(mode = 'integer')
    }

    #### penalty = 2, call proximalGraph
    #### requires `groups` and `groups_var` in integer matrices and `group_weights` in double vector
    if (penalty == 2) {
        if (missing(groups)) { stop('Required input `groups` is missing.') }
        if (missing(groups_var)) { stop('Required input `groups_var` is missing.') }
        if (missing(group_weights)) { stop('Required input `group_weights` is missing.') }
        group_id <- rep(0L, p)
        own_variables <- vector(mode = 'integer')
        N_own_variables <- vector(mode = 'integer')
    }

    #### penalty = 3, call proximalGraph
    #### requires `own_variables` and `N_own_variables` in integer vectors, `group_weights` in double vector
    #### and `groups` in integer matrix
    if (penalty == 3) {
        if (missing(groups)) { stop('Required input `groups` is missing.') }
        if (missing(own_variables)) { stop('Required input `own_variables` is missing.') }
        if (missing(N_own_variables)) { stop('Required input `N_own_variables` is missing.') }
        if (missing(group_weights)) { stop('Required input `group_weights` is missing.') }
        group_id <- rep(0L, p)
        groups_var <- matrix(NA)
    }

    ## call mtool main function
    result <- MultinomLogistic(X = X, Y = Y, offset = offset, K = K, reg_p = p - N_covariates,
                               penalty = penalty, regul = regularization, transpose = transpose,
                               grp_id = group_id, etaG = group_weights,
                               grp = groups, grpV = groups_var,
                               own_var = own_variables, N_own_var = N_own_variables,
                               lam1 = lambda1, lam2 = lambda2, lam3 = lambda3,
                               learning_rate = learning_rate, tolerance = tolerance,
                               niter_inner = niter_inner_mtplyr * nx, maxit = maxit,
                               ncores = ncores)
    nzc <- length(result$`Sparse Estimates`@i)
    return(list(coefficients = result$`Sparse Estimates`,
                no_non_zero = nzc))
}
